<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Reachy Dance Duo - Pollen Robotics</title>
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700;800&display=swap"
		rel="stylesheet">
	<style>
		:root {
			--primary: #FF9900;
			--primary-glow: rgba(255, 153, 0, 0.4);
			--dark-bg: #0A0A0A;
			--card-bg: #141414;
			--text-main: #FFFFFF;
			--text-dim: #A0A0A0;
			--accent-blue: #00D1FF;
		}

		* {
			box-sizing: border-box;
			margin: 0;
			padding: 0;
		}

		body {
			font-family: 'Outfit', sans-serif;
			background-color: var(--dark-bg);
			color: var(--text-main);
			line-height: 1.6;
			overflow-x: hidden;
		}

		/* --- Hero Section & 3D Canvas --- */
		.hero {
			position: relative;
			height: 80vh;
			display: flex;
			align-items: center;
			justify-content: center;
			text-align: center;
			padding: 2rem;
			overflow: hidden;
		}

		#visualizer-container {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			z-index: 0;
			opacity: 1.0;
		}

		.hero-content {
			max-width: 800px;
			z-index: 1;
			pointer-events: none;
		}

		.hero h1 {
			font-size: 4rem;
			font-weight: 800;
			margin-bottom: 1rem;
			background: linear-gradient(90deg, #FFFFFF, var(--primary));
			-webkit-background-clip: text;
			background-clip: text;
			-webkit-text-fill-color: transparent;
			letter-spacing: -1px;
		}

		/* Overlay Controls for Demo */
		#demo-controls {
			position: absolute;
			bottom: 20px;
			left: 50%;
			transform: translateX(-50%);
			z-index: 10;
			pointer-events: auto;
		}

		.audio-toggle-btn {
			background: rgba(255, 153, 0, 0.2);
			border: 1px solid var(--primary);
			color: #fff;
			padding: 10px 25px;
			border-radius: 30px;
			cursor: pointer;
			font-family: 'Outfit', sans-serif;
			font-weight: 600;
			transition: all 0.3s ease;
		}

		.audio-toggle-btn:hover {
			background: var(--primary);
			color: black;
			box-shadow: 0 0 20px var(--primary-glow);
		}

		/* --- Editor UI STYLES --- */
		#builder-panel {
			position: absolute;
			top: 20px;
			right: 20px;
			width: 220px;
			background: rgba(0, 20, 20, 0.9);
			border: 1px solid #0ff;
			color: #0ff;
			padding: 15px;
			border-radius: 8px;
			font-family: 'Outfit', sans-serif;
			box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
			z-index: 1001;
		}

		#builder-panel.hidden {
			display: none;
		}

		#builder-panel h3 {
			margin-top: 0;
			color: #fff;
			text-transform: uppercase;
			font-size: 0.9em;
			border-bottom: 1px solid #0ff;
			padding-bottom: 5px;
		}

		.coord-row {
			display: flex;
			justify-content: space-between;
			margin: 5px 0;
			align-items: center;
		}

		.coord-divider {
			border-bottom: 1px solid #444;
			margin: 10px 0 5px;
			font-size: 0.8em;
			color: #888;
			text-transform: uppercase;
		}

		#svg-panel pre,
		#builder-panel pre {
			background: rgba(0, 0, 0, 0.5);
			padding: 10px;
			border-radius: 4px;
			font-size: 10px;
			color: #0ff;
			overflow-x: auto;
			margin-top: 10px;
			border: 1px solid rgba(0, 255, 255, 0.2);
			white-space: pre-wrap;
			font-family: monospace;
		}

		.robot-control-group {
			border-top: 1px solid rgba(0, 255, 255, 0.2);
			padding-top: 10px;
			margin-top: 10px;
		}

		.robot-control-group h4 {
			margin: 0 0 8px 0;
			font-size: 12px;
			color: #fff;
		}

		.action-btn {
			width: 100%;
			background: #0ff;
			color: #000;
			border: none;
			padding: 10px;
			cursor: pointer;
			font-weight: bold;
			margin-top: 5px;
			text-transform: uppercase;
			font-size: 0.8rem;
		}

		.action-btn.secondary {
			background: transparent;
			border: 1px solid #0ff;
			color: #0ff;
		}

		#btn-builder-toggle {
			position: fixed;
			bottom: 30px;
			right: 30px;
			background: rgba(0, 0, 0, 0.7);
			border: 1px solid #0ff;
			border-radius: 50%;
			width: 50px;
			height: 50px;
			font-size: 24px;
			cursor: pointer;
			z-index: 1000;
			transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
			color: #0ff;
		}

		#btn-builder-toggle:hover {
			background: #0ff;
			color: #000;
			box-shadow: 0 0 25px #0ff;
			transform: scale(1.15) rotate(15deg);
		}

		#btn-robot-toggle {
			position: fixed;
			bottom: 90px;
			right: 30px;
			background: rgba(20, 0, 20, 0.7);
			border: 1px solid #f0f;
			border-radius: 50%;
			width: 50px;
			height: 50px;
			font-size: 24px;
			cursor: pointer;
			z-index: 1000;
			transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
			color: #f0f;
		}

		#btn-robot-toggle:hover {
			background: #f0f;
			color: #000;
			box-shadow: 0 0 25px #f0f;
			transform: scale(1.15);
		}

		#svg-panel {
			position: absolute;
			top: 20px;
			right: 20px;
			width: 280px;
			background: rgba(0, 0, 0, 0.85);
			backdrop-filter: blur(12px);
			border: 1px solid rgba(255, 255, 255, 0.1);
			border-radius: 12px;
			padding: 20px;
			color: white;
			font-family: 'Outfit', sans-serif;
			z-index: 1002;
			box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
		}

		#svg-panel h3 {
			margin: 0 0 15px 0;
			font-size: 14px;
			text-transform: uppercase;
			letter-spacing: 2px;
			color: #FF9900;
		}

		.control-group {
			margin-bottom: 14px;
			display: flex;
			align-items: center;
			justify-content: space-between;
		}

		.control-group label {
			font-size: 12px;
			color: #bbb;
			font-weight: 500;
		}

		.control-group input[type="range"] {
			width: 60%;
			accent-color: #FF9900;
		}

		.control-group input[type="color"] {
			border: 1px solid #444;
			width: 45px;
			height: 28px;
			background: #222;
			cursor: pointer;
			border-radius: 4px;
		}

		/* technical section overrides */
		.section {
			padding: 6rem 2rem;
			max-width: 1200px;
			margin: 0 auto;
			background: var(--dark-bg);
		}

		.grid {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
			gap: 2rem;
		}

		.card {
			background: var(--card-bg);
			padding: 2.5rem;
			border-radius: 24px;
			border: 1px solid rgba(255, 255, 255, 0.05);
		}

		.step-num {
			width: 40px;
			height: 40px;
			background: var(--primary);
			color: black;
			border-radius: 50%;
			display: flex;
			align-items: center;
			justify-content: center;
			font-weight: 800;
			margin-bottom: 1.5rem;
		}
	</style>
</head>

<body>

	<section class="hero">
		<div id="visualizer-container"></div>

		<!-- UI PANELS FOR AESTHETIC FINE-TUNING -->
		<div id="builder-panel" class="hidden">
			<h3>Robot Placement</h3>
			<div class="robot-control-group">
				<h4>Left Robot</h4>
				<div class="coord-row"><label>X</label><input type="range" id="l-pos-x" min="-10" max="10" step="0.01"
						value="-0.87"></div>
				<div class="coord-row"><label>Y</label><input type="range" id="l-pos-y" min="-5" max="5" step="0.01"
						value="-1.45"></div>
				<div class="coord-row"><label>Z</label><input type="range" id="l-pos-z" min="-20" max="5" step="0.1"
						value="-1.0"></div>
				<div class="coord-row"><label>Yaw</label><input type="range" id="l-rot-y" min="-3.14" max="3.14"
						step="0.01" value="-1.08"></div>
			</div>
			<div class="robot-control-group">
				<h4>Right Robot</h4>
				<div class="coord-row"><label>X</label><input type="range" id="r-pos-x" min="-10" max="10" step="0.01"
						value="0.80"></div>
				<div class="coord-row"><label>Y</label><input type="range" id="r-pos-y" min="-5" max="5" step="0.01"
						value="-1.45"></div>
				<div class="coord-row"><label>Z</label><input type="range" id="r-pos-z" min="-20" max="5" step="0.1"
						value="-0.70"></div>
				<div class="coord-row"><label>Yaw</label><input type="range" id="r-rot-y" min="-3.14" max="3.14"
						step="0.01" value="-2.07"></div>
			</div>

			<div class="coord-divider">TOOLS</div>
			<div class="coord-row">
				<label>Show Grid</label>
				<input type="checkbox" id="chk-show-grid">
			</div>
			<div class="coord-row">
				<label>Snap to Grid</label>
				<input type="checkbox" id="chk-snap">
			</div>
			<div class="coord-row">
				<label>Snap Step</label>
				<input type="number" id="snap-step" value="0.5" step="0.1"
					style="width: 50px; background:#222; border:1px solid #444; color:#fff; border-radius:4px;">
			</div>

			<div class="coord-divider">HARD-CODE SNIPPET</div>
			<pre id="robot-readout">// Robot Coordinates</pre>

			<button id="btn-lock" class="action-btn">üîì Lock Position</button>
			<button id="btn-cancel" class="action-btn secondary">Close</button>
		</div>

		<button id="btn-builder-toggle" title="Logo Editor">üõ†Ô∏è</button>
		<button id="btn-robot-toggle" title="Robot Placement">ü§ñ</button>

		<div id="svg-panel" style="display: none;">
			<h3>Logo Editor</h3>
			<div class="control-group"><label>Scale</label><input type="range" id="svg-scale" min="0.0005" max="0.005"
					step="0.0001" value="0.0037"></div>
			<div class="control-group"><label>Color</label><input type="color" id="svg-color" value="#f7cf02"></div>
			<div class="control-group"><label>Glow</label><input type="range" id="svg-glow" min="0" max="5" step="0.1"
					value="1.8"></div>
			<div class="control-group"><label>Bloom Radius</label><input type="range" id="bloom-radius" min="0" max="2"
					step="0.01" value="0.39"></div>
			<div class="control-group"><label>Bloom Strength</label><input type="range" id="bloom-strength" min="0"
					max="5" step="0.1" value="0.1"></div>
			<div class="control-group"><label>Bloom Threshold</label><input type="range" id="bloom-threshold" min="0"
					max="2.0" step="0.1" value="1.5"></div>
			<div class="control-group"><label>Tilt</label><input type="range" id="svg-tilt" min="-0.2" max="0.2"
					step="0.001" value="0.041"></div>
			<div class="control-group"><label>Depth (Z)</label><input type="range" id="svg-z" min="-50" max="100"
					step="0.1" value="-4.5"></div>
			<div class="control-group"><label>Offset Y</label><input type="range" id="svg-y" min="0" max="3" step="0.1"
					value="1.4"></div>
			<div class="control-group"><label>Drift</label><input type="range" id="drift-speed" min="0" max="2"
					step="0.1" value="1.4"></div>
			<div class="control-group"><label>Beam Pos Y</label><input type="range" id="red-beam" min="0" max="1"
					step="0.01" value="0.35"></div>
			<div class="control-group"><label>Beam Feather</label><input type="range" id="beam-feather" min="0" max="1"
					step="0.01" value="0.33"></div>

			<div class="coord-divider">LIVE CONFIG SNIPPET</div>
			<pre id="svg-readout">// Logo Config</pre>

			<button id="btn-save-svg" class="action-btn">üíæ Save Config (Persistent)</button>
		</div>

		<div id="demo-controls">
			<button id="toggleAudio" class="audio-toggle-btn">
				üîä Start Demo Audio
			</button>
		</div>
	</section>

	<section class="section">
		<h2 class="section-title">How it Works</h2>
		<div class="grid">
			<div class="card">
				<div class="step-num">1</div>
				<h3>Connect</h3>
				<p>Launch the app from your Reachy Mini dashboard. The 3D visualizer will automatically link to your
					robot sensors.</p>
			</div>
			<div class="card">
				<div class="step-num">2</div>
				<h3>Pick a Mode</h3>
				<p>Choose <strong>Live Groove</strong> to dance to ambient sounds, or <strong>Beat Bandit</strong> to
					choreograph to tracks.</p>
			</div>
			<div class="card">
				<div class="step-num">3</div>
				<h3>Customize</h3>
				<p>Adjust intensity, amplitude, and safety parameters in real-time. Watch the robots react in the
					visualizer.</p>
			</div>
			<div class="card">
				<div class="step-num">4</div>
				<h3>Dance!</h3>
				<p>Hit start and watch Reachy Mini perform. The dual-robot kinematics ensure smooth, expressive
					movements.</p>
			</div>
		</div>
	</section>

	<footer>
		<p>&copy; 2026 Pollen Robotics. Built for Reachy Mini.</p>
	</footer>

	<audio id="dance-audio" src="dance_duo.wav" crossorigin="anonymous" loop></audio>

	<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

	<script type="module">
		import * as THREE from 'three';
		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
		import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
		import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
		import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
		import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
		import { ReachyRobot } from './js/reachy_robot.js';
		import { MusicNoteSystem, SVG3DSystem, getRainbowColor } from './js/visualizer.js';

		const container = document.getElementById('visualizer-container');
		const scene = new THREE.Scene();
		const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
		camera.position.set(0.06650214614867994, -0.5509992498139562, 3.885498842512818);

		const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.setPixelRatio(window.devicePixelRatio);
		renderer.setClearColor(0x000000, 1);
		renderer.toneMapping = THREE.ReinhardToneMapping;
		container.appendChild(renderer.domElement);

		const renderScene = new RenderPass(scene, camera);
		const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
		bloomPass.threshold = 1.5;
		bloomPass.strength = 0.3;
		bloomPass.radius = 0.39;
		const outputPass = new OutputPass();

		const composer = new EffectComposer(renderer);
		composer.addPass(renderScene);
		composer.addPass(bloomPass);
		composer.addPass(outputPass);

		const controls = new OrbitControls(camera, renderer.domElement);
		controls.target.set(0.22978033215455446, -0.23017558883193248, 0.0037882423081313974);
		controls.update();

		const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
		scene.add(ambientLight);
		const keyLight = new THREE.DirectionalLight(0xffffff, 2.0);
		keyLight.position.set(5, 10, 7);
		scene.add(keyLight);

		const svgSystem = new SVG3DSystem(scene);
		svgSystem.load('assets/dance_duo.svg');
		const noteSystem = new MusicNoteSystem(scene);

		// Visualizer Blocks
		const visualizerGroup = new THREE.Group();
		scene.add(visualizerGroup);
		const blocks = [];
		const columns = 96;
		const centerCol = 47.5;
		const mapping = [11, 9, 7, 5, 3, 1, 0, 2, 4, 6, 8, 10];
		const panelGeometry = new THREE.PlaneGeometry(2.4, 1.25);

		for (let col = 0; col < columns; col++) {
			const columnBlocks = [];
			for (let row = 0; row < 12; row++) {
				const mat = new THREE.MeshStandardMaterial({ color: 0x111111, emissive: 0x000000, transparent: true, opacity: 0.05 });
				const block = new THREE.Mesh(panelGeometry, mat);
				block.position.set((col - centerCol) * 2.5, (row - 6) * 1.3, -50);
				visualizerGroup.add(block);
				columnBlocks.push({ mesh: block, material: mat });
			}
			blocks.push(columnBlocks);
		}
		visualizerGroup.scale.set(0.2, 0.2, 0.2);
		visualizerGroup.position.set(0, 0, -5);

		const rowPeaks = Array.from({ length: 12 }, () => ({ left: 40.5, right: 54.5 }));

		// Audio
		const audio = document.getElementById('dance-audio');
		const audioToggle = document.getElementById('toggleAudio');
		let audioContext, analyser, dataArray;
		let audioStarted = false;

		audioToggle.addEventListener('click', async () => {
			if (!audioContext) {
				audioContext = new (window.AudioContext || window.webkitAudioContext)();
				const source = audioContext.createMediaElementSource(audio);
				analyser = audioContext.createAnalyser();
				analyser.fftSize = 2048;
				source.connect(analyser);
				source.connect(audioContext.destination);
				dataArray = new Uint8Array(analyser.frequencyBinCount);
				audioStarted = true;
			}
			if (audioContext.state === 'suspended') await audioContext.resume();
			if (audio.paused) { audio.play(); audioToggle.textContent = '‚è∏ Pause Audio'; }
			else { audio.pause(); audioToggle.textContent = 'üîä Start Audio'; }
		});

		const leftRobot = new ReachyRobot('Left', 0, false);
		const rightRobot = new ReachyRobot('Right', 0, true);
		let danceData = null, startTime = 0;

		async function startAnimation() {
			try {
				const [danceRes] = await Promise.all([
					fetch('dance_data.json'),
					leftRobot.load('reachy_mini.xml'),
					rightRobot.load('reachy_mini.xml')
				]);
				scene.add(leftRobot.group);
				scene.add(rightRobot.group);

				leftRobot.group.position.set(-0.87, -1.45, -1);
				leftRobot.group.rotation.set(-1.57, -1.08, 0);
				rightRobot.group.position.set(0.80, -1.45, -0.70);
				rightRobot.group.rotation.set(-1.57, -2.07, 0);

				danceData = (await danceRes.json()).frames || [];
				startTime = performance.now();
				animate();
			} catch (e) { console.error(e); }
		}

		function animate() {
			requestAnimationFrame(animate);
			const time = performance.now();
			if (danceData && danceData.length > 0) {
				const currentTime = audioStarted ? audio.currentTime : (time - startTime) / 1000;
				const frame = danceData[Math.floor(currentTime * 30) % danceData.length];
				leftRobot.applyPose(frame);
				rightRobot.applyPose(frame);
			}

			const bandVolumes = new Array(12).fill(0);
			if (audioStarted && analyser) {
				analyser.getByteFrequencyData(dataArray);
				const binSize = Math.floor(dataArray.length / 12);
				for (let r = 0; r < 12; r++) {
					let sum = 0;
					for (let i = 0; i < binSize; i++) sum += dataArray[r * binSize + i];
					bandVolumes[r] = (sum / binSize) / 255;
				}
			}

			for (let r = 0; r < 12; r++) {
				const rowVol = bandVolumes[mapping[r]] || 0;
				const halfW = 7 + (rowVol * 41);
				const start = Math.floor(centerCol - halfW);
				const end = Math.ceil(centerCol + halfW);
				for (let c = 0; c < columns; c++) {
					const block = blocks[c][r];
					if (c >= start && c <= end) {
						block.material.opacity = 0.9;
						block.material.emissive.copy(getRainbowColor((c - start) / (end - start || 1)));
						block.material.emissiveIntensity = 0.8 + rowVol * 0.5;
					} else {
						block.material.opacity = 0.05;
						block.material.emissive.setHex(0x000000);
					}
				}
			}

			if (noteSystem) noteSystem.update(0.016);
			if (svgSystem) svgSystem.update(0.016);
			composer.render();
		}

		function setupSVGEditor() {
			const inputs = {
				scale: document.getElementById('svg-scale'),
				color: document.getElementById('svg-color'),
				glow: document.getElementById('svg-glow'),
				radius: document.getElementById('bloom-radius'),
				strength: document.getElementById('bloom-strength'),
				threshold: document.getElementById('bloom-threshold'),
				tilt: document.getElementById('svg-tilt'),
				z: document.getElementById('svg-z'),
				y: document.getElementById('svg-y'),
				drift: document.getElementById('drift-speed'),
				redBeam: document.getElementById('red-beam'),
				beamFeather: document.getElementById('beam-feather')
			};
			const readout = document.getElementById('svg-readout');
			const toggleBtn = document.getElementById('btn-builder-toggle');
			const panel = document.getElementById('svg-panel');

			toggleBtn.addEventListener('click', () => {
				panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
				document.getElementById('builder-panel').classList.add('hidden'); // Close other panel
			});

			function updateSVG() {
				bloomPass.radius = parseFloat(inputs.radius.value);
				bloomPass.strength = parseFloat(inputs.strength.value);
				bloomPass.threshold = parseFloat(inputs.threshold.value);
				if (!svgSystem?.loadedMesh) return;
				svgSystem.config.z = parseFloat(inputs.z.value);
				svgSystem.config.y = parseFloat(inputs.y.value);
				svgSystem.config.drift = parseFloat(inputs.drift.value);
				svgSystem.config.redBeam = parseFloat(inputs.redBeam.value);
				svgSystem.config.beamFeather = parseFloat(inputs.beamFeather.value);
				svgSystem.loadedMesh.scale.setScalar(parseFloat(inputs.scale.value));
				svgSystem.loadedMesh.rotation.z = parseFloat(inputs.tilt.value);
				svgSystem.updateTexture(inputs.color.value, svgSystem.config.redBeam, svgSystem.config.beamFeather);
				const g = parseFloat(inputs.glow.value);
				svgSystem.loadedMesh.traverse(n => {
					if (n.isPointLight) n.intensity = g * 6;
					if (n.isMesh && n.name === "CoreLetter") n.material.emissiveIntensity = g;
				});
				readout.innerText = `svgSystem.config = ${JSON.stringify(svgSystem.config, null, 2)};\nbloomPass.threshold = ${bloomPass.threshold};\nbloomPass.strength = ${bloomPass.strength};\nbloomPass.radius = ${bloomPass.radius};`;
			}
			Object.values(inputs).forEach(i => i.addEventListener('input', updateSVG));
			window.addEventListener('svg-loaded', () => setTimeout(updateSVG, 100));
		}

		function setupRobotEditor() {
			const robots = {
				left: { obj: leftRobot, x: document.getElementById('l-pos-x'), y: document.getElementById('l-pos-y'), z: document.getElementById('l-pos-z'), rotY: document.getElementById('l-rot-y') },
				right: { obj: rightRobot, x: document.getElementById('r-pos-x'), y: document.getElementById('r-pos-y'), z: document.getElementById('r-pos-z'), rotY: document.getElementById('r-rot-y') }
			};
			const readout = document.getElementById('robot-readout');
			const robotToggle = document.getElementById('btn-robot-toggle');
			const builderPanel = document.getElementById('builder-panel');
			const showGridCheck = document.getElementById('chk-show-grid');
			const snapCheck = document.getElementById('chk-snap');
			const snapStepInput = document.getElementById('snap-step');

			// Separate Toggle for Robot Panel
			robotToggle.addEventListener('click', () => {
				builderPanel.classList.toggle('hidden');
				document.getElementById('svg-panel').style.display = 'none'; // Close other panel
				// Enable edit mode visualizer if panel is open?
			});
			document.getElementById('btn-cancel').addEventListener('click', () => builderPanel.classList.add('hidden'));

			// Dot Grid Logic
			const points = [];
			for (let x = -8; x <= 8; x += 0.5) {
				for (let z = -12; z <= 5; z += 0.5) {
					points.push(x, -1.5, z);
				}
			}
			const dotGeometry = new THREE.BufferGeometry();
			dotGeometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
			const dotMaterial = new THREE.PointsMaterial({ color: 0x00D1FF, size: 0.04 });
			const dotGrid = new THREE.Points(dotGeometry, dotMaterial);
			dotGrid.visible = false;
			scene.add(dotGrid);

			if (showGridCheck) showGridCheck.addEventListener('change', (e) => dotGrid.visible = e.target.checked);

			// Selection Logic (Raycaster)
			const raycaster = new THREE.Raycaster();
			const mouse = new THREE.Vector2();
			const selectionBox = new THREE.BoxHelper(new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1)), 0x00FFFF);
			selectionBox.visible = false;
			scene.add(selectionBox);

			window.addEventListener('click', (event) => {
				if (builderPanel.classList.contains('hidden')) return;

				// Calculate mouse position
				mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
				mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

				raycaster.setFromCamera(mouse, camera);

				// Check intersection with robot groups
				// Note: complex because groups hold meshes. Simplify by checking distance?
				// Or traverse meshes. For now, we cycle selection or check simple bounds.
				// Simple approach: if click near center of robot.
				// Better:
				const intersects = raycaster.intersectObjects(scene.children, true);
				let selected = null;
				for (let i = 0; i < intersects.length; i++) {
					// Check if object belongs to a robot
					let p = intersects[i].object;
					while (p.parent) {
						if (p === leftRobot.group) { selected = 'left'; break; }
						if (p === rightRobot.group) { selected = 'right'; break; }
						p = p.parent;
					}
					if (selected) break;
				}

				if (selected) {
					const target = selected === 'left' ? leftRobot : rightRobot;

					// Highlight visual
					selectionBox.setFromObject(target.group);
					selectionBox.visible = true;

					// Could auto-focus controls here if we wanted
				} else {
					// Maybe clear selection if clicking void?
					// selectionBox.visible = false;
				}
			});


			function updateRobots() {
				const isSnap = snapCheck ? snapCheck.checked : false;
				const step = snapStepInput ? parseFloat(snapStepInput.value) : 0.5;

				[robots.left, robots.right].forEach(r => {
					if (!r.obj?.group) return;

					let x = parseFloat(r.x.value);
					let y = parseFloat(r.y.value);
					let z = parseFloat(r.z.value);
					let rot = parseFloat(r.rotY.value);

					if (isSnap) {
						x = Math.round(x / step) * step;
						y = Math.round(y / step) * step;
						z = Math.round(z / step) * step;
					}

					r.obj.group.position.set(x, y, z);
					r.obj.group.rotation.y = rot;

					// Update helper if visible and matching
				});

				readout.innerText = `leftRobot.group.position.set(${robots.left.obj.group.position.x.toFixed(2)}, ${robots.left.obj.group.position.y.toFixed(2)}, ${robots.left.obj.group.position.z.toFixed(2)});\n` +
					`leftRobot.group.rotation.y = ${robots.left.obj.group.rotation.y.toFixed(2)};\n` +
					`rightRobot.group.position.set(${robots.right.obj.group.position.x.toFixed(2)}, ${robots.right.obj.group.position.y.toFixed(2)}, ${robots.right.obj.group.position.z.toFixed(2)});\n` +
					`rightRobot.group.rotation.y = ${robots.right.obj.group.rotation.y.toFixed(2)};`;
			}

			[...Object.values(robots.left), ...Object.values(robots.right)].forEach(el => { if (el instanceof HTMLElement) el.addEventListener('input', updateRobots); });
			if (snapCheck) snapCheck.addEventListener('change', updateRobots);
			if (snapStepInput) snapStepInput.addEventListener('input', updateRobots);

			setTimeout(updateRobots, 500);
		}

		setupSVGEditor();
		setupRobotEditor();
		startAnimation();

		window.addEventListener('resize', () => {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
			composer.setSize(window.innerWidth, window.innerHeight);
		});
	</script>
</body>

</html>