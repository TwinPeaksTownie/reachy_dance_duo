<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Reachy Dance Duo - Pollen Robotics</title>
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700;800&display=swap"
		rel="stylesheet">
	<style>
		:root {
			--primary: #FF9900;
			--primary-glow: rgba(255, 153, 0, 0.4);
			--dark-bg: #0A0A0A;
			--card-bg: #141414;
			--text-main: #FFFFFF;
			--text-dim: #A0A0A0;
			--accent-blue: #00D1FF;
		}

		* {
			box-sizing: border-box;
			margin: 0;
			padding: 0;
		}

		body {
			font-family: 'Outfit', sans-serif;
			background-color: var(--dark-bg);
			color: var(--text-main);
			line-height: 1.6;
			overflow-x: hidden;
		}

		/* --- Hero Section & 3D Canvas --- */
		.hero {
			position: relative;
			height: 80vh;
			display: flex;
			align-items: center;
			justify-content: center;
			text-align: center;
			padding: 2rem;
			overflow: hidden;
		}

		#visualizer-container {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			z-index: 0;
			opacity: 1.0;
		}

		.hero-content {
			max-width: 800px;
			z-index: 1;
			pointer-events: none;
		}

		.hero h1 {
			font-size: 4rem;
			font-weight: 800;
			margin-bottom: 1rem;
			background: linear-gradient(90deg, #FFFFFF, var(--primary));
			-webkit-background-clip: text;
			background-clip: text;
			-webkit-text-fill-color: transparent;
			letter-spacing: -1px;
		}

		/* Overlay Controls for Demo */
		#demo-controls {
			position: absolute;
			bottom: 20px;
			left: 50%;
			transform: translateX(-50%);
			z-index: 10;
			pointer-events: auto;
		}

		.audio-toggle-btn {
			background: rgba(255, 153, 0, 0.2);
			border: 1px solid var(--primary);
			color: #fff;
			padding: 10px 25px;
			border-radius: 30px;
			cursor: pointer;
			font-family: 'Outfit', sans-serif;
			font-weight: 600;
			transition: all 0.3s ease;
		}

		.audio-toggle-btn:hover {
			background: var(--primary);
			color: black;
			box-shadow: 0 0 20px var(--primary-glow);
		}

		/* --- Editor UI STYLES --- */
		#builder-panel {
			position: absolute;
			top: 20px;
			right: 20px;
			width: 220px;
			background: rgba(0, 20, 20, 0.9);
			border: 1px solid #0ff;
			color: #0ff;
			padding: 15px;
			border-radius: 8px;
			font-family: 'Outfit', sans-serif;
			box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
			z-index: 1001;
		}

		#builder-panel.hidden {
			display: none;
		}

		#builder-panel h3 {
			margin-top: 0;
			color: #fff;
			text-transform: uppercase;
			font-size: 0.9em;
			border-bottom: 1px solid #0ff;
			padding-bottom: 5px;
		}

		.coord-row {
			display: flex;
			justify-content: space-between;
			margin: 5px 0;
			align-items: center;
		}

		.coord-divider {
			border-bottom: 1px solid #444;
			margin: 10px 0 5px;
			font-size: 0.8em;
			color: #888;
			text-transform: uppercase;
		}

		#svg-panel pre,
		#builder-panel pre {
			background: rgba(0, 0, 0, 0.5);
			padding: 10px;
			border-radius: 4px;
			font-size: 10px;
			color: #0ff;
			overflow-x: auto;
			margin-top: 10px;
			border: 1px solid rgba(0, 255, 255, 0.2);
			white-space: pre-wrap;
			font-family: monospace;
		}

		.robot-control-group {
			border-top: 1px solid rgba(0, 255, 255, 0.2);
			padding-top: 10px;
			margin-top: 10px;
		}

		.robot-control-group h4 {
			margin: 0 0 8px 0;
			font-size: 12px;
			color: #fff;
		}

		.action-btn {
			width: 100%;
			background: #0ff;
			color: #000;
			border: none;
			padding: 10px;
			cursor: pointer;
			font-weight: bold;
			margin-top: 5px;
			text-transform: uppercase;
			font-size: 0.8rem;
		}

		.action-btn.secondary {
			background: transparent;
			border: 1px solid #0ff;
			color: #0ff;
		}

		#btn-builder-toggle {
			position: fixed;
			bottom: 30px;
			right: 30px;
			background: rgba(0, 0, 0, 0.7);
			border: 1px solid #0ff;
			border-radius: 50%;
			width: 50px;
			height: 50px;
			font-size: 24px;
			cursor: pointer;
			z-index: 1000;
			transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
			color: #0ff;
		}

		#btn-builder-toggle:hover {
			background: #0ff;
			color: #000;
			box-shadow: 0 0 25px #0ff;
			transform: scale(1.15) rotate(15deg);
		}

		#btn-robot-toggle {
			position: fixed;
			bottom: 90px;
			right: 30px;
			background: rgba(20, 0, 20, 0.7);
			border: 1px solid #f0f;
			border-radius: 50%;
			width: 50px;
			height: 50px;
			font-size: 24px;
			cursor: pointer;
			z-index: 1000;
			transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
			color: #f0f;
		}

		#btn-robot-toggle:hover {
			background: #f0f;
			color: #000;
			box-shadow: 0 0 25px #f0f;
			transform: scale(1.15);
		}

		/* --- MONOLITHIC EDITOR STYLES --- */
		.nudge-btn {
			width: 25px;
			height: 25px;
			border: 1px solid #0ff;
			background: rgba(0, 40, 40, 0.5);
			color: #0ff;
			cursor: pointer;
			font-size: 14px;
			padding: 0;
			display: flex;
			align-items: center;
			justify-content: center;
			border-radius: 4px;
			margin: 0 5px;
		}

		.nudge-btn:hover {
			background: #0ff;
			color: #000;
		}

		.tools-row {
			display: flex;
			gap: 5px;
			margin-top: 10px;
		}

		.tool-btn {
			flex: 1;
			background: #222;
			border: 1px solid #0ff;
			color: #0ff;
			cursor: pointer;
			padding: 5px;
			font-size: 0.8em;
		}

		.tool-btn.active {
			background: #0ff;
			color: #000;
		}

		.slide-row {
			display: flex;
			align-items: center;
			justify-content: space-between;
			margin: 5px 0;
		}

		.slide-val {
			width: 30px;
			text-align: right;
			font-size: 0.8em;
			color: #fff;
		}

		#svg-panel {
			position: absolute;
			top: 20px;
			right: 20px;
			width: 280px;
			background: rgba(0, 0, 0, 0.85);
			backdrop-filter: blur(12px);
			border: 1px solid rgba(255, 255, 255, 0.1);
			border-radius: 12px;
			padding: 20px;
			color: white;
			font-family: 'Outfit', sans-serif;
			z-index: 1002;
			box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
		}

		#svg-panel h3 {
			margin: 0 0 15px 0;
			font-size: 14px;
			text-transform: uppercase;
			letter-spacing: 2px;
			color: #FF9900;
		}

		.control-group {
			margin-bottom: 14px;
			display: flex;
			align-items: center;
			justify-content: space-between;
		}

		.control-group label {
			font-size: 12px;
			color: #bbb;
			font-weight: 500;
		}

		.control-group input[type="range"] {
			width: 60%;
			accent-color: #FF9900;
		}

		.control-group input[type="color"] {
			border: 1px solid #444;
			width: 45px;
			height: 28px;
			background: #222;
			cursor: pointer;
			border-radius: 4px;
		}

		/* technical section overrides */
		.section {
			padding: 6rem 2rem;
			max-width: 1200px;
			margin: 0 auto;
			background: var(--dark-bg);
		}

		.grid {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
			gap: 2rem;
		}

		.card {
			background: var(--card-bg);
			padding: 2.5rem;
			border-radius: 24px;
			border: 1px solid rgba(255, 255, 255, 0.05);
		}

		.step-num {
			width: 40px;
			height: 40px;
			background: var(--primary);
			color: black;
			border-radius: 50%;
			display: flex;
			align-items: center;
			justify-content: center;
			font-weight: 800;
			margin-bottom: 1.5rem;
		}
	</style>
</head>

<body>

	<section class="hero">
		<div id="visualizer-container"></div>

		<!-- UI PANELS FOR AESTHETIC FINE-TUNING -->
		<div id="builder-panel" class="hidden">
			<h3>Placement Mode</h3>
			<p>Selected: <span id="builder-target">None</span></p>

			<div class="coord-row">
				<label>X:</label> <span id="val-x">0.00</span>
			</div>
			<div class="coord-row">
				<label>Y:</label> <span id="val-y">0.00</span>
			</div>
			<div class="coord-row">
				<label>Z:</label> <span id="val-z">0.00</span>
			</div>

			<div class="coord-divider">ROTATION (Deg)</div>
			<div class="slide-row">
				<label>X</label>
				<button class="nudge-btn" data-axis="x" data-dir="-1">-</button>
				<input type="range" id="rot-x" min="-180" max="180" step="1">
				<button class="nudge-btn" data-axis="x" data-dir="1">+</button>
				<span id="disp-rot-x" class="slide-val">0</span>
			</div>
			<div class="slide-row">
				<label>Y</label>
				<button class="nudge-btn" data-axis="y" data-dir="-1">-</button>
				<input type="range" id="rot-y" min="-180" max="180" step="1">
				<button class="nudge-btn" data-axis="y" data-dir="1">+</button>
				<span id="disp-rot-y" class="slide-val">0</span>
			</div>
			<div class="slide-row">
				<label>Z</label>
				<button class="nudge-btn" data-axis="z" data-dir="-1">-</button>
				<input type="range" id="rot-z" min="-180" max="180" step="1">
				<button class="nudge-btn" data-axis="z" data-dir="1">+</button>
				<span id="disp-rot-z" class="slide-val">0</span>
			</div>

			<div class="tools-row">
				<button id="btn-mode-trans" class="tool-btn active">Move</button>
				<button id="btn-mode-rot" class="tool-btn">Rotate</button>
			</div>

			<button id="btn-lock" class="action-btn">üîí Lock Position</button>
			<button id="btn-cancel" class="action-btn secondary">Cancel</button>

			<div class="coord-divider">ALIGNMENT</div>
			<div class="tools-row">
				<button id="btn-snap" class="action-btn secondary" style="margin-top:0;">üß≤ Snap to Grid</button>
			</div>

			<div class="coord-divider">PERSISTENCE</div>
			<button id="btn-save-disk" class="action-btn" style="background:#44ff44; color:#000;">üíæ Save to
				Disk</button>

			<div class="coord-divider">CAMERA POV</div>
			<div class="coord-row"><label>Pos:</label> <span id="cam-pos">0, 0, 0</span></div>
			<div class="coord-row"><label>Rot:</label> <span id="cam-rot">0, 0, 0</span></div>
		</div>

		<button id="btn-builder-toggle" title="Logo Editor">üõ†Ô∏è</button>
		<button id="btn-robot-toggle" title="Robot Placement">ü§ñ</button>

		<div id="svg-panel" style="display: none;">
			<h3>Logo Editor</h3>
			<div class="control-group"><label>Scale</label><input type="range" id="svg-scale" min="0.0005" max="0.005"
					step="0.0001" value="0.0037"></div>
			<div class="control-group"><label>Color</label><input type="color" id="svg-color" value="#f7cf02"></div>
			<div class="control-group"><label>Glow</label><input type="range" id="svg-glow" min="0" max="5" step="0.1"
					value="1.8"></div>
			<div class="control-group"><label>Bloom Radius</label><input type="range" id="bloom-radius" min="0" max="2"
					step="0.01" value="0.39"></div>
			<div class="control-group"><label>Bloom Strength</label><input type="range" id="bloom-strength" min="0"
					max="5" step="0.1" value="0.1"></div>
			<div class="control-group"><label>Bloom Threshold</label><input type="range" id="bloom-threshold" min="0"
					max="2.0" step="0.1" value="1.5"></div>
			<div class="control-group"><label>Tilt</label><input type="range" id="svg-tilt" min="-0.2" max="0.2"
					step="0.001" value="0.041"></div>
			<div class="control-group"><label>Depth (Z)</label><input type="range" id="svg-z" min="-50" max="100"
					step="0.1" value="-4.5"></div>
			<div class="control-group"><label>Offset Y</label><input type="range" id="svg-y" min="0" max="3" step="0.1"
					value="1.4"></div>
			<div class="control-group"><label>Drift</label><input type="range" id="drift-speed" min="0" max="2"
					step="0.1" value="1.4"></div>
			<div class="control-group"><label>Beam Pos Y</label><input type="range" id="red-beam" min="0" max="1"
					step="0.01" value="0.35"></div>
			<div class="control-group"><label>Beam Feather</label><input type="range" id="beam-feather" min="0" max="1"
					step="0.01" value="0.33"></div>

			<div class="coord-divider">LIVE CONFIG SNIPPET</div>
			<pre id="svg-readout">// Logo Config</pre>

			<button id="btn-save-svg" class="action-btn">üíæ Save Config (Persistent)</button>
		</div>

		<div id="demo-controls">
			<button id="toggleAudio" class="audio-toggle-btn">
				üîä Start Demo Audio
			</button>
		</div>
	</section>

	<section class="section">
		<h2 class="section-title">How it Works</h2>
		<div class="grid">
			<div class="card">
				<div class="step-num">1</div>
				<h3>Connect</h3>
				<p>Launch the app from your Reachy Mini dashboard. The 3D visualizer will automatically link to your
					robot sensors.</p>
			</div>
			<div class="card">
				<div class="step-num">2</div>
				<h3>Pick a Mode</h3>
				<p>Choose <strong>Live Groove</strong> to dance to ambient sounds, or <strong>Beat Bandit</strong> to
					choreograph to tracks.</p>
			</div>
			<div class="card">
				<div class="step-num">3</div>
				<h3>Customize</h3>
				<p>Adjust intensity, amplitude, and safety parameters in real-time. Watch the robots react in the
					visualizer.</p>
			</div>
			<div class="card">
				<div class="step-num">4</div>
				<h3>Dance!</h3>
				<p>Hit start and watch Reachy Mini perform. The dual-robot kinematics ensure smooth, expressive
					movements.</p>
			</div>
		</div>
	</section>

	<footer>
		<p>&copy; 2026 Pollen Robotics. Built for Reachy Mini.</p>
	</footer>

	<audio id="dance-audio" src="dance_duo.wav" crossorigin="anonymous" loop></audio>

	<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>

	<script type="module">
		import * as THREE from 'three';
		import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
		import { TransformControls } from 'three/addons/controls/TransformControls.js';
		import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
		import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
		import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
		import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
		import { ReachyRobot } from './js/reachy_robot.js';
		import { MusicNoteSystem, SVG3DSystem, getRainbowColor } from './js/visualizer.js';

		const container = document.getElementById('visualizer-container');
		const scene = new THREE.Scene();

		const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
		camera.position.set(-0.04, -0.62, 3.95);

		const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.setPixelRatio(window.devicePixelRatio);
		renderer.setClearColor(0x000000, 1);
		renderer.toneMapping = THREE.ReinhardToneMapping;
		container.appendChild(renderer.domElement);

		const renderScene = new RenderPass(scene, camera);
		const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
		bloomPass.threshold = 1.5;
		bloomPass.strength = 0.3;
		bloomPass.radius = 0.39;
		const outputPass = new OutputPass();

		const composer = new EffectComposer(renderer);
		composer.addPass(renderScene);
		composer.addPass(bloomPass);
		composer.addPass(outputPass);

		const controls = new OrbitControls(camera, renderer.domElement);
		controls.target.set(0, -1.0, 0); // Center focus between robots
		controls.update();

		const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
		scene.add(ambientLight);
		const keyLight = new THREE.DirectionalLight(0xffffff, 2.0);
		keyLight.position.set(5, 10, 7);
		scene.add(keyLight);

		const svgSystem = new SVG3DSystem(scene);
		svgSystem.load('assets/dance_duo.svg');
		const noteSystem = new MusicNoteSystem(scene);

		// Visualizer Blocks
		const visualizerGroup = new THREE.Group();
		scene.add(visualizerGroup);
		const blocks = [];

		// --- VISUALIZER CONSTANTS (Horseshoe) ---
		const columns = 96;
		const panelsTurn = 32;
		const panelsLeg = 32;
		const turnRadius = 25;
		const legLength = 80;
		const turnCenterZ = -50;
		const panelGeometry = new THREE.PlaneGeometry(2.4, 1.25);
		const mapping = [11, 9, 7, 5, 3, 1, 0, 2, 4, 6, 8, 10];

		for (let col = 0; col < columns; col++) {
			const columnBlocks = [];
			let x, z, rotY;

			if (col < panelsLeg) {
				// Left Leg
				x = -turnRadius;
				const legProgress = (panelsLeg - 1 - col) / panelsLeg;
				z = turnCenterZ + legProgress * legLength;
				rotY = Math.PI / 2;
			} else if (col < panelsLeg + panelsTurn) {
				// Turn (Horseshoe)
				const turnCol = col - panelsLeg;
				const pct = turnCol / (panelsTurn - 1);
				const angle = Math.PI * (1 - pct);
				x = turnRadius * Math.cos(angle);
				z = turnCenterZ - turnRadius * Math.sin(angle);
				rotY = angle - Math.PI / 2;
			} else {
				// Right Leg
				const rightCol = col - (panelsLeg + panelsTurn);
				const legProgress = rightCol / panelsLeg;
				x = turnRadius;
				z = turnCenterZ + legProgress * legLength;
				rotY = -Math.PI / 2;
			}

			for (let row = 0; row < 12; row++) {
				const mat = new THREE.MeshStandardMaterial({ color: 0x111111, emissive: 0x000000, transparent: true, opacity: 0.05, side: THREE.FrontSide });
				const block = new THREE.Mesh(panelGeometry, mat);
				block.position.set(x, (row - 6) * 1.28, z);
				block.rotation.y = rotY;
				visualizerGroup.add(block);
				columnBlocks.push({ mesh: block, material: mat });
			}
			blocks.push(columnBlocks);
		}
		visualizerGroup.scale.set(0.2, 0.2, 0.2);
		visualizerGroup.position.set(0, 0, -5);

		const rowPeaks = Array.from({ length: 12 }, () => ({ left: 40.5, right: 54.5 }));

		// Audio
		const audio = document.getElementById('dance-audio');
		const audioToggle = document.getElementById('toggleAudio');
		let audioContext, analyser, dataArray;
		let audioStarted = false;

		audioToggle.addEventListener('click', async () => {
			if (!audioContext) {
				audioContext = new (window.AudioContext || window.webkitAudioContext)();
				const source = audioContext.createMediaElementSource(audio);
				analyser = audioContext.createAnalyser();
				analyser.fftSize = 2048;
				source.connect(analyser);
				source.connect(audioContext.destination);
				dataArray = new Uint8Array(analyser.frequencyBinCount);
				audioStarted = true;
			}
			if (audioContext.state === 'suspended') await audioContext.resume();
			if (audio.paused) { audio.play(); audioToggle.textContent = '‚è∏ Pause Audio'; }
			else { audio.pause(); audioToggle.textContent = 'üîä Start Audio'; }
		});

		const leftRobot = new ReachyRobot('Left', 0, false);
		const rightRobot = new ReachyRobot('Right', 0, true);
		let danceData = null, startTime = 0;

		async function startAnimation() {
			try {
				const [danceRes] = await Promise.all([
					fetch('dance_data.json'),
					leftRobot.load('reachy_mini.xml'),
					rightRobot.load('reachy_mini.xml')
				]);
				scene.add(leftRobot.group);
				scene.add(rightRobot.group);

				// --- DEFINITIVE COORDINATES (From Screenshots) ---
				// Left: Pos(-1.00, -1.45, -1.00), Rot(-90, 0, -45)
				leftRobot.group.position.set(-1.00, -1.45, -1.00);
				leftRobot.group.rotation.set(THREE.MathUtils.degToRad(-90), THREE.MathUtils.degToRad(0), THREE.MathUtils.degToRad(-45));

				// Right: Pos(0.80, -1.45, -0.70), Rot(-90, 1, -135)
				rightRobot.group.position.set(0.80, -1.45, -0.70);
				rightRobot.group.rotation.set(THREE.MathUtils.degToRad(-90), THREE.MathUtils.degToRad(1), THREE.MathUtils.degToRad(-135));

				danceData = (await danceRes.json()).frames || [];
				startTime = performance.now();
				animate();
			} catch (e) { console.error(e); }
		}

		function animate() {
			requestAnimationFrame(animate);
			const time = performance.now();
			if (danceData && danceData.length > 0) {
				const currentTime = audioStarted ? audio.currentTime : (time - startTime) / 1000;
				const frame = danceData[Math.floor(currentTime * 30) % danceData.length];
				leftRobot.applyPose(frame);
				rightRobot.applyPose(frame);
			}

			const bandVolumes = new Array(12).fill(0);
			if (audioStarted && analyser) {
				analyser.getByteFrequencyData(dataArray);
				const binSize = Math.floor(dataArray.length / 12);
				for (let r = 0; r < 12; r++) {
					let sum = 0;
					for (let i = 0; i < binSize; i++) sum += dataArray[r * binSize + i];
					// Gain Boost (1.6x)
					bandVolumes[r] = Math.min(((sum / binSize) / 255) * 1.6, 1.0);
				}
				// Dampen dominant bass (Exact Backup Values)
				bandVolumes[0] *= 0.6;
				bandVolumes[1] *= 0.7;
				bandVolumes[2] *= 0.8;
			}

			if (noteSystem) {
				// Spawn Check (using calculated bandVolumes)
				// Highs are roughly indexes 8-11
				const highVol = (bandVolumes[9] + bandVolumes[10] + bandVolumes[11]) / 3;

				if (highVol > 0.4 && Math.random() < 0.075) {
					const isLeft = Math.random() > 0.5;
					const sourceRobot = isLeft ? leftRobot : rightRobot;
					if (sourceRobot && sourceRobot.group) {
						const spawnPos = sourceRobot.group.position.clone();
						spawnPos.y += 0.4;
						const color = new THREE.Color(0xffffff); // Force White
						noteSystem.spawn(spawnPos, color);
					}
				}
			}

			const centerCol = 47.5;
			const baseHalfWidth = 7;
			const maxHalfWidth = 48;

			const rowVolumes = new Array(12).fill(0);
			for (let r = 0; r < 12; r++) {
				rowVolumes[r] = bandVolumes[mapping[r]] || 0;
			}

			for (let r = 0; r < 12; r++) {
				const rowVol = rowVolumes[r];
				// Elastic Expansion
				const expansion = rowVol * (maxHalfWidth - baseHalfWidth);
				const currentHalfWidth = baseHalfWidth + expansion;

				const startColLimit = Math.floor(centerCol - currentHalfWidth);
				const endColLimit = Math.ceil(centerCol + currentHalfWidth);

				// Leader Peak Decay Logic (Exact Backup)
				if (rowPeaks[r].left > startColLimit) rowPeaks[r].left -= 1.0;
				if (rowPeaks[r].left < startColLimit) rowPeaks[r].left = startColLimit;

				if (rowPeaks[r].right < endColLimit) rowPeaks[r].right += 1.0;
				if (rowPeaks[r].right > endColLimit) rowPeaks[r].right = endColLimit;

				for (let c = 0; c < columns; c++) {
					const blockData = blocks[c][r];
					const block = blockData.mesh;
					const mat = blockData.material;

					let isLit = false;
					let isLeader = false;
					let colorScalar = 0;

					if (c >= startColLimit && c <= endColLimit) {
						isLit = true;
						colorScalar = (c - startColLimit) / (endColLimit - startColLimit || 1);
					}

					if (c === Math.floor(rowPeaks[r].left)) { isLeader = true; isLit = true; colorScalar = 0.0; }
					if (c === Math.floor(rowPeaks[r].right)) { isLeader = true; isLit = true; colorScalar = 1.0; }

					if (isLit) {
						const color = getRainbowColor(colorScalar);
						mat.opacity = 0.9;
						mat.emissive.copy(color);
						// CAP emission at 0.9 to stay BELOW the Bloom Threshold (1.1)
						const rawIntensity = 0.8 + (rowVol * 0.5);
						mat.emissiveIntensity = Math.min(rawIntensity, 0.9);

						if (isLeader) {
							mat.emissiveIntensity = 0.95;
						}
					} else {
						mat.opacity = 0.05;
						mat.emissive.setHex(0x000000);
						mat.emissiveIntensity = 0;
					}
				}
			}

			if (noteSystem) noteSystem.update(0.016);
			if (svgSystem) svgSystem.update(0.016);
			composer.render();
		}

		function setupSVGEditor() {
			const inputs = {
				scale: document.getElementById('svg-scale'),
				color: document.getElementById('svg-color'),
				glow: document.getElementById('svg-glow'),
				radius: document.getElementById('bloom-radius'),
				strength: document.getElementById('bloom-strength'),
				threshold: document.getElementById('bloom-threshold'),
				tilt: document.getElementById('svg-tilt'),
				z: document.getElementById('svg-z'),
				y: document.getElementById('svg-y'),
				drift: document.getElementById('drift-speed'),
				redBeam: document.getElementById('red-beam'),
				beamFeather: document.getElementById('beam-feather')
			};
			const readout = document.getElementById('svg-readout');
			const toggleBtn = document.getElementById('btn-builder-toggle');
			const panel = document.getElementById('svg-panel');

			toggleBtn.addEventListener('click', () => {
				panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
				document.getElementById('builder-panel').classList.add('hidden'); // Close other panel
			});

			function updateSVG() {
				bloomPass.radius = parseFloat(inputs.radius.value);
				bloomPass.strength = parseFloat(inputs.strength.value);
				bloomPass.threshold = parseFloat(inputs.threshold.value);
				if (!svgSystem?.loadedMesh) return;
				svgSystem.config.z = parseFloat(inputs.z.value);
				svgSystem.config.y = parseFloat(inputs.y.value);
				svgSystem.config.drift = parseFloat(inputs.drift.value);
				svgSystem.config.redBeam = parseFloat(inputs.redBeam.value);
				svgSystem.config.beamFeather = parseFloat(inputs.beamFeather.value);
				svgSystem.loadedMesh.scale.setScalar(parseFloat(inputs.scale.value));
				svgSystem.loadedMesh.rotation.z = parseFloat(inputs.tilt.value);
				svgSystem.updateTexture(inputs.color.value, svgSystem.config.redBeam, svgSystem.config.beamFeather);
				const g = parseFloat(inputs.glow.value);
				svgSystem.loadedMesh.traverse(n => {
					if (n.isPointLight) n.intensity = g * 6;
					if (n.isMesh && n.name === "CoreLetter") n.material.emissiveIntensity = g;
				});
				readout.innerText = `svgSystem.config = ${JSON.stringify(svgSystem.config, null, 2)};\nbloomPass.threshold = ${bloomPass.threshold};\nbloomPass.strength = ${bloomPass.strength};\nbloomPass.radius = ${bloomPass.radius};`;
			}
			Object.values(inputs).forEach(i => i.addEventListener('input', updateSVG));
			window.addEventListener('svg-loaded', () => setTimeout(updateSVG, 100));
		}

		// --- BUILDER / PLACEMENT MODE ---
		let transformControl;
		let builderModeActive = false;
		let selectedRobotName = null;
		let ghostObject = null;
		let originalObject = null;
		let gridHelper = null;
		let snapGroup = null;
		let highlightedSnap = null;

		const raycaster = new THREE.Raycaster();
		const mouse = new THREE.Vector2();

		function setupRobotEditor() {
			// UI Elements
			const builderPanel = document.getElementById('builder-panel');
			const builderToggle = document.getElementById('btn-robot-toggle'); // Using Robot Toggle for this

			const lockBtn = document.getElementById('btn-lock');
			const cancelBtn = document.getElementById('btn-cancel');

			// Rotation Sliders
			const sliderRotX = document.getElementById('rot-x');
			const sliderRotY = document.getElementById('rot-y');
			const sliderRotZ = document.getElementById('rot-z');

			const btnMove = document.getElementById('btn-mode-trans');
			const btnRot = document.getElementById('btn-mode-rot');
			const btnSnap = document.getElementById('btn-snap');
			const btnSave = document.getElementById('btn-save-disk');

			// Toggle Panel Logic
			builderToggle.addEventListener('click', () => {
				const isHidden = builderPanel.classList.contains('hidden');
				if (isHidden) {
					builderPanel.classList.remove('hidden');
					document.getElementById('svg-panel').style.display = 'none';
					initBuilderMode();
				} else {
					exitBuilderMode(); // Also closes panel
				}
			});

			// Gizmo Mode Toggles
			btnMove.addEventListener('click', () => {
				if (transformControl) transformControl.setMode('translate');
				btnMove.classList.add('active');
				btnRot.classList.remove('active');
			});
			btnRot.addEventListener('click', () => {
				if (transformControl) transformControl.setMode('rotate');
				btnRot.classList.add('active');
				btnMove.classList.remove('active');
			});

			// Slider Logic
			function onSliderChange() {
				if (!ghostObject) return;
				const rx = parseFloat(sliderRotX.value);
				const ry = parseFloat(sliderRotY.value);
				const rz = parseFloat(sliderRotZ.value);

				ghostObject.rotation.x = THREE.MathUtils.degToRad(rx);
				ghostObject.rotation.y = THREE.MathUtils.degToRad(ry);
				ghostObject.rotation.z = THREE.MathUtils.degToRad(rz);

				document.getElementById('disp-rot-x').innerText = rx.toFixed(0);
				document.getElementById('disp-rot-y').innerText = ry.toFixed(0);
				document.getElementById('disp-rot-z').innerText = rz.toFixed(0);
			}
			sliderRotX.addEventListener('input', onSliderChange);
			sliderRotY.addEventListener('input', onSliderChange);
			sliderRotZ.addEventListener('input', onSliderChange);

			// Nudge Button Logic
			document.querySelectorAll('.nudge-btn').forEach(btn => {
				btn.addEventListener('click', (e) => {
					if (!ghostObject) return;
					const axis = btn.getAttribute('data-axis');
					const dir = parseInt(btn.getAttribute('data-dir'));
					const slider = document.getElementById(`rot-${axis}`);

					let val = parseInt(slider.value) + dir;
					if (val > 180) val = -180;
					if (val < -180) val = 180;

					slider.value = val;
					onSliderChange();
				});
			});

			btnSnap.addEventListener('click', () => {
				if (!ghostObject) return;
				// Snap Position to nearest 0.5m grid
				ghostObject.position.x = Math.round(ghostObject.position.x * 2) / 2;
				ghostObject.position.z = Math.round(ghostObject.position.z * 2) / 2;
				ghostObject.position.y = -1.45; // Floor level

				// Snap Rotations to nearest 90 degrees
				const snap90 = (val) => Math.round(val / (Math.PI / 2)) * (Math.PI / 2);
				ghostObject.rotation.set(snap90(ghostObject.rotation.x), snap90(ghostObject.rotation.y), snap90(ghostObject.rotation.z));
				updateBuilderUI();
			});

			btnSave.addEventListener('click', () => {
				const config = {
					robots: {
						"Left": { position: leftRobot.group.position.toArray(), rotation: leftRobot.group.rotation.toArray().slice(0, 3) },
						"Right": { position: rightRobot.group.position.toArray(), rotation: rightRobot.group.rotation.toArray().slice(0, 3) }
					},
					camera: { position: camera.position.toArray(), target: controls.target.toArray() }
				};
				console.log("üíæ CONFIG TO SAVE:", JSON.stringify(config, null, 2));
				alert("Config logged to console! (Copy it to robot_config.json)");
			});

			lockBtn.addEventListener('click', () => {
				if (ghostObject && originalObject) {
					originalObject.position.copy(ghostObject.position);
					originalObject.rotation.copy(ghostObject.rotation);
					discardGhost();
				}
			});

			cancelBtn.addEventListener('click', discardGhost);
		}

		function initBuilderMode() {
			if (!transformControl) {
				transformControl = new TransformControls(camera, renderer.domElement);
				transformControl.addEventListener('dragging-changed', (event) => controls.enabled = !event.value);
				transformControl.addEventListener('change', updateBuilderUI);
				scene.add(transformControl);
			}

			// Interactive Grid (Spheres)
			if (!snapGroup) {
				snapGroup = new THREE.Group();
				const snapGeo = new THREE.SphereGeometry(0.05, 8, 8);
				const snapMat = new THREE.MeshBasicMaterial({ color: 0x888888, transparent: true, opacity: 0.3 });

				for (let x = -10; x <= 10; x++) {
					for (let z = -10; z <= 10; z++) {
						const dot = new THREE.Mesh(snapGeo, snapMat.clone());
						dot.position.set(x, -1.5, z);
						snapGroup.add(dot);
					}
				}
				scene.add(snapGroup);
			}

			transformControl.enabled = true;
			document.body.style.cursor = 'crosshair';
			window.addEventListener('click', onBuilderClick);
			window.addEventListener('mousemove', onBuilderMove);
		}

		function exitBuilderMode() {
			if (transformControl) { transformControl.detach(); transformControl.enabled = false; }
			if (ghostObject) discardGhost();
			if (snapGroup) { scene.remove(snapGroup); snapGroup = null; }

			document.getElementById('builder-panel').classList.add('hidden');
			window.removeEventListener('click', onBuilderClick);
			window.removeEventListener('mousemove', onBuilderMove);
			document.body.style.cursor = 'default';
		}

		function onBuilderMove(event) {
			if (!snapGroup) return;
			// Raycast for hover effect
			mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
			mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
			raycaster.setFromCamera(mouse, camera);

			if (highlightedSnap) {
				highlightedSnap.material.opacity = 0.3;
				highlightedSnap.material.color.setHex(0x888888);
				highlightedSnap.scale.set(1, 1, 1);
				highlightedSnap = null;
			}

			const intersects = raycaster.intersectObjects(snapGroup.children);
			if (intersects.length > 0) {
				highlightedSnap = intersects[0].object;
				highlightedSnap.material.opacity = 1.0;
				highlightedSnap.material.color.setHex(0x00FFFF);
				highlightedSnap.scale.set(2.5, 2.5, 2.5);
			}

			// Camera Readout Update
			const r2d = (r) => (r * (180 / Math.PI)).toFixed(1);
			document.getElementById('cam-pos').innerText = `${camera.position.x.toFixed(2)}, ${camera.position.y.toFixed(2)}, ${camera.position.z.toFixed(2)}`;
			document.getElementById('cam-rot').innerText = `${r2d(camera.rotation.x)}, ${r2d(camera.rotation.y)}, ${r2d(camera.rotation.z)}`;
		}

		function onBuilderClick(event) {
			if (document.getElementById('builder-panel').classList.contains('hidden')) return;

			mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
			mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
			raycaster.setFromCamera(mouse, camera);

			// 1. Check Snap Points
			if (ghostObject && snapGroup) {
				const intersects = raycaster.intersectObjects(snapGroup.children);
				if (intersects.length > 0) {
					const pt = intersects[0].object.position;
					ghostObject.position.set(pt.x, -1.45, pt.z);
					updateBuilderUI();
					return;
				}
			}

			if (ghostObject) return; // Already editing?

			// 2. Select Robot
			const intersects = raycaster.intersectObjects([leftRobot.group, rightRobot.group], true);
			if (intersects.length > 0) {
				let hit = intersects[0].object;
				// Walk up to find group
				while (hit.parent && hit !== leftRobot.group && hit !== rightRobot.group) hit = hit.parent;
				const robot = (hit === leftRobot.group) ? leftRobot : rightRobot;
				selectForEditing(robot);
			}
		}

		function selectForEditing(robot) {
			selectedRobotName = robot.name;
			originalObject = robot.group;
			ghostObject = originalObject.clone();

			// Fix Ghost Material (Teal)
			const tealMat = new THREE.MeshBasicMaterial({ color: 0x00FFFF, wireframe: true, transparent: true, opacity: 0.3 });
			ghostObject.traverse(c => { if (c.isMesh) c.material = tealMat; });

			// Green Pancake Magnet
			const magGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.002, 32);
			const magMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
			const magMesh = new THREE.Mesh(magGeo, magMat);
			magMesh.rotation.x = Math.PI / 2; // Flat
			// Center at bottom
			const box = new THREE.Box3().setFromObject(ghostObject);
			const center = box.getCenter(new THREE.Vector3());
			magMesh.position.set(center.x, box.min.y, center.z);
			ghostObject.add(magMesh);

			// Axis Lines
			const addAxis = (p1, p2, col) => {
				const g = new THREE.BufferGeometry().setFromPoints([p1, p2]);
				const m = new THREE.LineBasicMaterial({ color: col });
				ghostObject.add(new THREE.Line(g, m));
			};
			addAxis(new THREE.Vector3(-100, 0, 0), new THREE.Vector3(100, 0, 0), 0xffff00); // X Yellow
			addAxis(new THREE.Vector3(0, -100, 0), new THREE.Vector3(0, 100, 0), 0x0000ff); // Y Blue
			addAxis(new THREE.Vector3(0, 0, -100), new THREE.Vector3(0, 0, 100), 0xff00ff); // Z Magenta

			scene.add(ghostObject);
			transformControl.attach(ghostObject);

			document.getElementById('builder-target').innerText = robot.name;
			updateBuilderUI();
		}

		function updateBuilderUI() {
			if (!ghostObject) return;
			document.getElementById('val-x').innerText = ghostObject.position.x.toFixed(2);
			document.getElementById('val-y').innerText = ghostObject.position.y.toFixed(2);
			document.getElementById('val-z').innerText = ghostObject.position.z.toFixed(2);

			const d = (r) => THREE.MathUtils.radToDeg(r).toFixed(0);
			document.getElementById('rot-x').value = d(ghostObject.rotation.x);
			document.getElementById('rot-y').value = d(ghostObject.rotation.y);
			document.getElementById('rot-z').value = d(ghostObject.rotation.z);

			document.getElementById('disp-rot-x').innerText = d(ghostObject.rotation.x);
			document.getElementById('disp-rot-y').innerText = d(ghostObject.rotation.y);
			document.getElementById('disp-rot-z').innerText = d(ghostObject.rotation.z);
		}

		function discardGhost() {
			if (transformControl) transformControl.detach();
			if (ghostObject) { scene.remove(ghostObject); ghostObject = null; }
			document.getElementById('builder-target').innerText = "None";
		}

		setupSVGEditor();
		setupRobotEditor();
		startAnimation();

		window.addEventListener('resize', () => {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
			composer.setSize(window.innerWidth, window.innerHeight);
		});
	</script>
</body>

</html>